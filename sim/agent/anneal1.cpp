/*
 * Parameter searching with the RetinoTectal model
 *
 * Launch with a base json config for the model which can incorporate initial values for
 * parameters and with a second config which will specify the parameters to
 * optimise. Any experiment configs will be either generated by this code or loaded from
 * known locations.
 */

#include <string>
#include <vector>
#include <morph/tools.h>
#include <morph/Config.h>
#include <morph/Anneal.h>
#include "agent1.h"

// A count of the number of sims.
unsigned int model_sim_count = 0;

// Objective function involves running the agent based model
template <typename T=float, size_t N=4>
T objfn (Agent1<T, N, branch<T, N>>& model1,
         morph::Config* mconf,
         const std::vector<std::string>& params,
         const morph::vVector<T>& param_values)
{
    // Set params in model(s)
    model1.reset();
    for (size_t i = 0; i < params.size(); ++i) {
        mconf->set (params[i], param_values[i]);
    }
    model1.update_m();

    // Run model and then get metrics
    model1.run();
    ++model_sim_count;
    AgentMetrics<T> m1m = model1.get_metrics();

    // Here's a combination of the sos differences between the expected map and the actual map, plus a cross count.
    std::cout << "wt expt sos: " << m1m.sos << std::endl;
    std::cout << "Sim count: " << model_sim_count << std::endl;
    T rtn = m1m.sos;

    return rtn;
}

// E.g.: pbm && ./build/sim/agent/search1c configs/a1/m_eE_GCI.json configs/a1/s_GCI.json
int main (int argc, char **argv)
{
    // Set up config objects
    std::string paramsfile_mdl("");
    std::string paramsfile_srch("");
    // The 'model id' and 'search id' are derived from their JSON files' names
    std::string m_id("");
    std::string s_id("");

    static constexpr size_t expected_args = 2;
    if (argc == (expected_args+1)) {
        // Two arguments. The first is the model config and the second is the search config
        paramsfile_mdl = std::string(argv[1]);
        std::string fname = paramsfile_mdl; // e.g.: m_el.json
        morph::Tools::stripUnixPath (fname);
        // Find the thing between "m_" and ".json"
        std::vector<std::string> one = morph::Tools::stringToVector (fname, ".json");
        if (!one.empty()) {
            std::vector<std::string> two = morph::Tools::stringToVector (one[0], "m_");
            // two should have size 2, with the first entry an empty string
            if (two.size() > 1) { m_id = two[1]; }
            one.clear();
        }

        paramsfile_srch = std::string(argv[2]);
        fname = paramsfile_srch; // e.g.: s_GJ.json or s_GI.json
        morph::Tools::stripUnixPath (fname);
        // Find the thing between "s_" and ".json"
        one = morph::Tools::stringToVector (fname, ".json");
        if (!one.empty()) {
            std::vector<std::string> two = morph::Tools::stringToVector (one[0], "s_");
            if (two.size() > 1) { s_id = two[1]; }
        }
    } else {
        std::cerr << "Require " << expected_args << " args\n";
        return 1;
    }

    morph::Config* sconf = new morph::Config (paramsfile_srch);
    morph::Config* mconf = new morph::Config (paramsfile_mdl);

    // Check configs
    bool need_exit = false;
    if (!sconf->ready) {
        std::cerr << "Failed to read search(i.e. optimization) config " << paramsfile_srch << ". Exiting.\n";
        need_exit = true;
    }
    if (!mconf->ready) {
        std::cerr << "Failed to read model config " << paramsfile_mdl << ". Exiting.\n";
        need_exit = true;
    }
    if (need_exit) {
        delete sconf;
        delete mconf;
        return 1;
    }

    morph::Tools::createDirIf ("./log/agent");
    std::string base_path = std::string("./log/agent/") + m_id + std::string("_") + s_id;
    std::string outfile = base_path + std::string(".h5");
    std::string outfile_js = base_path + std::string(".json");
    std::string branch_model = mconf->getString ("branch_model", "james_agent");
    size_t num_guiders = mconf->getInt("num_guiders", 4);

    // Open s_*.json and get the array "params".
    std::vector<std::string> params;
    morph::vVector<double> param_values;
    morph::vVector<morph::Vector<double,2>> param_ranges;
    Json::Value params_j = sconf->getArray ("params");
    for (auto p : params_j) {
        params.push_back (p.asString());
        param_values.push_back (mconf->getFloat(p.asString(), 0));
        // Set ranges for the params
        if (params.back() == "r_c") {
            param_ranges.push_back ({0.001, 0.5});
        } else if (params.back() == "r_i") {
            param_ranges.push_back ({0.001, 0.5});
        } else if (params.back() == "r_j") {
            param_ranges.push_back ({0.001, 0.5});
        } else if (params.back() == "s") {
            param_ranges.push_back ({0.01, 0.99});
        } else if (params.back() == "m_g") {
            param_ranges.push_back ({0.0001, 0.01});
        } else if (params.back() == "m_c") {
            param_ranges.push_back ({0.01, 0.1});
        } else if (params.back() == "m_i") {
            param_ranges.push_back ({0.01, 0.8});
        } else if (params.back() == "m_j") {
            param_ranges.push_back ({0.00001, 0.001});
        }
    }

    morph::Anneal<double> optimiser (param_values, param_ranges);
    // Anneal ASA params from sconf:
    optimiser.temperature_ratio_scale = sconf->getDouble ("temperature_ratio_scale", 1e-4);
    optimiser.temperature_anneal_scale = sconf->getDouble ("temperature_anneal_scale", 200.0);
    optimiser.cost_parameter_scale_ratio = sconf->getDouble ("cost_parameter_scale_ratio", 1.5);
    optimiser.acc_gen_reanneal_ratio = sconf->getDouble ("acc_gen_reanneal_ratio", 0.3);
    optimiser.partials_samples = sconf->getUInt ("partials_samples", 4);
    optimiser.f_x_best_repeat_max = sconf->getUInt ("f_x_best_repeat_max", 15);
    optimiser.reanneal_after_steps = sconf->getUInt ("reanneal_after_steps", 100);
    optimiser.init();

    if (num_guiders == 4) {

        // for (each expt) {

        // Create/use an expt config
        std::string paramsfile_expt = "./configs/a1/e_wt.json";
        morph::Config* econf1 = new morph::Config (paramsfile_expt);
        Agent1<float, 4, branch<float, 4>> model1 (econf1, mconf);
        model1.title = std::string("j4_") + m_id + std::string("_1_s_") + s_id;
        model1.immediate_exit = true;
        model1.randomly_seeded = false;

        // ASA optimisation
        while (optimiser.state != morph::Anneal_State::ReadyToStop) {
            if (optimiser.state == morph::Anneal_State::NeedToCompute) {
                //std::vector<float> xc = static_cast<std::vector<float>>(optimiser.x_cand.as_float());
                morph::vVector<float> xc = optimiser.x_cand.as_float();
                optimiser.f_x_cand = objfn (model1, mconf, params, xc);

            } else if (optimiser.state == morph::Anneal_State::NeedToComputeSet) {
                for (unsigned int i = 0; i < optimiser.partials_samples; ++i) {
                    optimiser.f_x_set[i] = objfn (model1, mconf, params, optimiser.x_set[i].as_float());
                }
            } else {
                throw std::runtime_error ("Unexpected state for anneal object.");
            }
            optimiser.step();
        }

        std::cout << "After optimization (simulated " << model_sim_count << " times):\n";

        morph::vVector<double> final_params = optimiser.x_best;
        if (params.size() != final_params.size()) { throw std::runtime_error ("Uh oh"); }
        for (size_t i = 0; i < params.size(); ++i) {
            std::cout << params[i] << " = " << final_params[i] << std::endl;
        }

        std::string mdl_conf_out("./m_");
        mdl_conf_out += m_id + "_fin.json";
        mconf->write (mdl_conf_out);
        if (mconf->ready == true) {
            std::cout << "Wrote optimised model to file " << mdl_conf_out << std::endl;
        } else {
            std::cerr << "Failed to write optimised model to file " << mdl_conf_out << std::endl;
        }
        delete econf1;

    } else if (num_guiders == 2) {
        std::cerr << "Not implemented for num_guiders == 2\n";
    }

    delete sconf;
    delete mconf;
    return 0;
}
