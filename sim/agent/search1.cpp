/*
 * Parameter searching with the RetinoTectal model
 *
 * Launch with a base json config for the model which can incorporate initial values for
 * parameters and with a second config which will specify the parameters to
 * optimise. Any experiment configs will be either generated by this code or loaded from
 * known locations.
 */

#include <string>
#include <vector>
#include <morph/tools.h>
#include <morph/Config.h>
#include "agent1.h"

int main (int argc, char **argv)
{
    // Set up config objects
    std::string paramsfile_mdl("");
    std::string paramsfile_srch("");
    // The 'model id' and 'search id' are derived from their JSON files' names
    std::string m_id("");
    std::string s_id("");

    static constexpr size_t expected_args = 2;
    if (argc == (expected_args+1)) {
        // Two arguments. The first is the model config and the second is the search config
        paramsfile_mdl = std::string(argv[1]);
        std::string fname = paramsfile_mdl; // e.g.: m_el.json
        morph::Tools::stripUnixPath (fname);
        // Find the thing between "m_" and ".json"
        std::vector<std::string> one = morph::Tools::stringToVector (fname, ".json");
        if (!one.empty()) {
            std::vector<std::string> two = morph::Tools::stringToVector (one[0], "m_");
            // two should have size 2, with the first entry an empty string
            if (two.size() > 1) { m_id = two[1]; }
            one.clear();
        }

        paramsfile_srch = std::string(argv[2]);
        fname = paramsfile_srch; // e.g.: s_GJ.json or s_GI.json
        morph::Tools::stripUnixPath (fname);
        // Find the thing between "s_" and ".json"
        one = morph::Tools::stringToVector (fname, ".json");
        if (!one.empty()) {
            std::vector<std::string> two = morph::Tools::stringToVector (one[0], "s_");
            if (two.size() > 1) { s_id = two[1]; }
        }
    } else {
        std::cerr << "Require " << expected_args << " args\n";
        return 1;
    }

    morph::Config* sconf = new morph::Config (paramsfile_srch);
    morph::Config* mconf = new morph::Config (paramsfile_mdl);

    // Check configs
    bool need_exit = false;
    if (!sconf->ready) {
        std::cerr << "Failed to read search(i.e. optimization) config " << paramsfile_srch << ". Exiting.\n";
        need_exit = true;
    }
    if (!mconf->ready) {
        std::cerr << "Failed to read model config " << paramsfile_mdl << ". Exiting.\n";
        need_exit = true;
    }
    if (need_exit) {
        delete sconf;
        delete mconf;
        return 1;
    }

    morph::Tools::createDirIf ("./log/agent");
    std::string base_path = std::string("./log/agent/") + m_id + std::string("_") + s_id;
    std::string outfile = base_path + std::string(".h5");
    std::string outfile_js = base_path + std::string(".json");
    std::string branch_model = mconf->getString ("branch_model", "james_agent");
    size_t num_guiders = mconf->getInt("num_guiders", 4);

    if (num_guiders == 4) {

        // for (each expt) {

        // Create/use an expt config
        std::string paramsfile_expt = "./configs/a1/e_wt.json";
        morph::Config* econf = new morph::Config (paramsfile_expt);
        Agent1<float, 4, branch<float, 4>> model (econf, mconf);
        model.title = std::string("j4_") + m_id + std::string("_") + s_id;
        model.immediate_exit = true;
        size_t i = 0;

        // For each expt (or group of expts? many models?) run, then adjust params, etc:
        while (i++<10) {
            model.run();
            //metrics = model.evaluate();
            //mconf->set ("param", x);
            model.reset();
        }
        model.save (outfile);
        //mconf.save (outfile_js);

        delete econf;

    } else if (num_guiders == 2) {
        // Similar to above but with:
        //Agent1<float, 2, branch<float, 2>> model (conf, mconf);
    }

    delete sconf;
    delete mconf;
    return 0;
}
